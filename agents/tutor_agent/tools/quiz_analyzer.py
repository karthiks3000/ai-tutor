"""
Analyze diagnostic quiz results to identify skill gaps and recommend learning paths
"""
import logging
from typing import Dict, Any, List
from models.constants import Subject, SUBJECT_SKILL_AREAS, DifficultyLevel

logger = logging.getLogger(__name__)

def analyze_diagnostic_results(
    quiz_result: Dict[str, Any],
    subject: Subject
) -> Dict[str, Any]:
    """
    Analyze diagnostic quiz results to identify skill gaps using AI-generated skill_areas tags.
    NO keyword matching - relies on skill_areas tags from quiz generator.
    
    Args:
        quiz_result: Quiz result with questions and answers (each question has skill_areas array)
        subject: Subject being assessed
        
    Returns:
        {
            "skill_scores": Dict[str, float],  # 0-100 per skill area
            "identified_gaps": List[str],      # Skills needing work
            "recommended_difficulty": str,      # beginner/intermediate/advanced
            "focus_areas": List[str],          # Priority skills (top 3 gaps)
            "overall_score": float,            # 0-100
            "strengths": List[str]             # Skills student is strong in
        }
    """
    # Get skill areas for this subject
    skill_areas = SUBJECT_SKILL_AREAS[subject]
    
    # Initialize skill scores
    skill_scores = {skill: 0.0 for skill in skill_areas}
    skill_question_counts = {skill: 0.0 for skill in skill_areas}  # Use float for fractional counts
    
    # Calculate per-skill scores using AI-generated skill_areas tags
    questions = quiz_result.get('questions', [])
    total_correct = 0
    
    for question in questions:
        is_correct = question.get('is_correct', False)
        if is_correct:
            total_correct += 1
        
        # Get skill_areas from question (generated by AI)
        question_skills = question.get('skill_areas', [])
        
        # If question has skill_areas tags, use them
        if question_skills:
            for skill in question_skills:
                if skill in skill_areas:
                    skill_question_counts[skill] += 1
                    if is_correct:
                        skill_scores[skill] += 100.0
        else:
            # Fallback: If no skill_areas tag (shouldn't happen), distribute to all skills
            logger.warning(f"Question {question.get('question_id', '?')} missing skill_areas tag!")
            for skill in skill_areas:
                skill_question_counts[skill] += 1.0 / len(skill_areas)
                if is_correct:
                    skill_scores[skill] += 100.0 / len(skill_areas)
    
    # Average scores per skill
    for skill in skill_areas:
        if skill_question_counts[skill] > 0:
            skill_scores[skill] /= skill_question_counts[skill]
        else:
            # If no questions for this skill, mark as neutral
            skill_scores[skill] = 50.0
    
    # Calculate overall score
    overall_score = (total_correct / len(questions)) * 100 if questions else 50.0
    
    # Identify gaps (scores < 60%)
    identified_gaps = sorted(
        [skill for skill, score in skill_scores.items() if score < 60],
        key=lambda s: skill_scores[s]
    )
    
    # Identify strengths (scores >= 75%)
    strengths = [skill for skill, score in skill_scores.items() if score >= 75]
    
    # Determine recommended difficulty
    if overall_score < 50:
        recommended_difficulty = DifficultyLevel.BEGINNER
    elif overall_score < 75:
        recommended_difficulty = DifficultyLevel.INTERMEDIATE
    else:
        recommended_difficulty = DifficultyLevel.ADVANCED
    
    # Focus areas = top 3 gaps (lowest scores)
    focus_areas = sorted(skill_scores.items(), key=lambda x: x[1])[:3]
    focus_areas = [skill for skill, _ in focus_areas if skill_scores[skill] < 70]
    
    # If no clear gaps, focus on middle-performing areas
    if not focus_areas:
        focus_areas = sorted(skill_scores.items(), key=lambda x: x[1])[len(skill_scores)//2:len(skill_scores)//2+3]
        focus_areas = [skill for skill, _ in focus_areas]
    
    return {
        "skill_scores": skill_scores,
        "identified_gaps": identified_gaps,
        "recommended_difficulty": recommended_difficulty.value,
        "focus_areas": focus_areas[:3],  # Top 3 priority skills
        "overall_score": overall_score,
        "strengths": strengths,
        "total_questions": len(questions),
        "correct_answers": total_correct
    }
